// types/db.ts
// Assuming this file primarily defines types that mirror database table structures.
// Many of these are already defined or are compatible with entity-resolution.ts.
// I'll add/clarify service-specific ones based on your schema description.

import { Pool, PoolConfig } from 'pg';

// Database connection configuration
export interface DbConfig extends PoolConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  ssl?: boolean | object;
}

// Human Feedback types
export interface HumanFeedbackDbRecord { // For clustering_metadata.human_feedback
  id: string; // uuid
  entity_group_id: string; // text, FK to entity_group
  is_match_correct: boolean;
  reviewer_id?: string; // text
  notes?: string; // text
  created_at?: Date; // timestamp, default CURRENT_TIMESTAMP
  updated_at?: Date; // timestamp, default CURRENT_TIMESTAMP
  match_decision_id: string; // text, FK to match_decision_details
}

// New Service Match Human Feedback type
export interface ServiceMatchHumanFeedbackDbRecord { // For clustering_metadata.service_match_human_feedback
  // id is typically auto-generated by the DB (e.g., serial or uuid)
  service_group_id: string; // text, FK to service_group.id
  match_decision_id: string; // text, FK to some decision table (ensure this exists for services or adapt)
  reviewer_id: string; // text
  feedback_timestamp: Date; // timestamp without time zone, default CURRENT_TIMESTAMP
  is_match_correct: boolean;
  notes?: string | null; // text
  processed_for_tuner_update_at?: Date | null; // timestamp without time zone
}


// Entity Group types
export interface EntityGroupDbRecord {
  id: string; // text, PK
  group_cluster_id: string | null; // text, FK to entity_group_cluster
  created_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  updated_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  confidence_score: number | null; // double precision
  entity_id_1: string; // text, NOT NULL
  entity_id_2: string; // text, NOT NULL
  method_type: string; // text, NOT NULL (part of UNIQUE constraint with entity_id_1, entity_id_2)
  match_values: Record<string, unknown> | null; // jsonb
  pre_rl_confidence_score: number | null; // double precision
  confirmed_status: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH' | 'DENIED'; // text, default 'PENDING_REVIEW'
  reviewed_at: Date | null; // timestamp without time zone
  reviewer_id: string | null; // text
}

// Service Group types (from your schema description)
export interface ServiceGroupDbRecord {
  id: string; // text, PK
  service_id_1: string; // character(36), NOT NULL (part of UNIQUE constraint with service_id_2, method_type)
  service_id_2: string; // character(36), NOT NULL (part of UNIQUE constraint with service_id_1, method_type)
  confidence_score: number | null; // double precision
  created_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  method_type: string; // text, NOT NULL (part of UNIQUE constraint with service_id_1, service_id_2)
  match_values: Record<string, unknown> | null; // jsonb
  pre_rl_confidence_score: number | null; // double precision
  confirmed_status: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH' | 'REJECTED'; // text, default 'PENDING_REVIEW'
  reviewed_at: Date | null; // timestamp without time zone
  reviewer_id: string | null; // text
  group_cluster_id: string | null; // text, FK to service_group_cluster.id
  updated_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
}


// Entity Group Cluster types
export interface EntityGroupClusterDbRecord {
  id: string; // text, PK
  name: string | null; // text
  description: string | null; // text
  created_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  updated_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  entity_count: number | null; // integer, default 0
  group_count: number | null; // integer, default 0
  average_coherence_score: number | null; // double precision
  // source_cluster_id and is_user_modified are not in your provided schema for entity_group_cluster
}

// Service Group Cluster types (from your schema description)
export interface ServiceGroupClusterDbRecord {
  id: string; // text, PK
  name: string | null; // text
  description: string | null; // text
  created_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  updated_at: Date | null; // timestamp without time zone, default CURRENT_TIMESTAMP
  service_count: number | null; // integer, default 0
  service_group_count: number | null; // integer, default 0
  average_coherence_score: number | null; // double precision
}

// Entity types (assuming this maps to an 'entities' table or similar)
export interface EntityDbRecord {
  id: string;
  organization_id?: string; // Assuming this might exist
  name: string | null;
  created_at: Date | null;
  updated_at: Date | null;
  source_system: string | null;
  source_id: string | null;
}

// Service types (assuming this maps to a 'services' table or similar)
export interface ServiceDbRecord {
  id: string; // Typically a UUID or other unique identifier
  name: string | null;
  // Add other fields relevant to a service, e.g., version, description, owner
  created_at: Date | null;
  updated_at: Date | null;
  source_system: string | null; // If services are ingested from different systems
  source_id: string | null;    // The ID of the service in its source system
}


// Entity Edge Visualization types
export interface EntityEdgeVisualizationDbRecord {
  id: string; // text, PK
  cluster_id: string; // text, NOT NULL (FK to entity_group_cluster.id)
  entity_id_1: string; // text, NOT NULL
  entity_id_2: string; // text, NOT NULL
  edge_weight: number; // double precision, NOT NULL
  details: Record<string, unknown> | null; // jsonb
  pipeline_run_id: string | null; // text
  created_at: Date; // timestamp without time zone, default CURRENT_TIMESTAMP, NOT NULL
  confirmed_status: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH'; // text, default 'PENDING_REVIEW'
  // updated_at is not in your provided schema for entity_edge_visualization
}

// Service Edge Visualization types (from your schema description)
export interface ServiceEdgeVisualizationDbRecord {
  id: string; // text, PK
  service_group_cluster_id: string; // text, NOT NULL (FK to service_group_cluster.id)
  service_id_1: string; // text, NOT NULL
  service_id_2: string; // text, NOT NULL
  edge_weight: number; // numeric(10,5), NOT NULL
  details: Record<string, unknown> | null; // jsonb
  pipeline_run_id: string; // text, NOT NULL (part of UNIQUE constraint with service_group_cluster_id, service_id_1, service_id_2)
  created_at: Date | null; // timestamp with time zone, default now()
  // confirmed_status is not in your provided schema for service_edge_visualization, but might be useful
}


// Database client configuration and helpers (assuming these remain the same)
export function getDbConfig(): DbConfig {
  return {
    host: process.env.POSTGRES_HOST || 'localhost',
    port: parseInt(process.env.POSTGRES_PORT || '5432', 10),
    database: process.env.POSTGRES_DB || 'dataplatform',
    user: process.env.POSTGRES_USER || 'postgres',
    password: process.env.POSTGRES_PASSWORD || '',
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
  };
}

let pool: Pool | null = null;

export function getDbPool(): Pool {
  if (!pool) {
    pool = new Pool(getDbConfig());
    pool.on('connect', () => {
      console.log('New database connection established');
    });
    pool.on('error', (err) => {
      console.error('Unexpected error on idle client', err);
      process.exit(-1);
    });
  }
  return pool;
}

export async function queryOne<T = any>(
  dbQuery: string,
  params: any[] = []
): Promise<T | null> {
  const client = await getDbPool().connect();
  try {
    const result = await client.query(dbQuery, params);
    return result.rows[0] || null;
  } finally {
    client.release();
  }
}

export async function query<T = any>(
  dbQuery: string,
  params: any[] = []
): Promise<T[]> {
  const client = await getDbPool().connect();
  try {
    const result = await client.query(dbQuery, params);
    return result.rows;
  } finally {
    client.release();
  }
}

export async function execute(
  dbQuery: string,
  params: any[] = []
): Promise<number> {
  const client = await getDbPool().connect();
  try {
    const result = await client.query(dbQuery, params);
    return result.rowCount || 0;
  } finally {
    client.release();
  }
}

export async function withTransaction<T>(
  callback: (client: any) => Promise<T>
): Promise<T> {
  const client = await getDbPool().connect();
  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (e) {
    await client.query('ROLLBACK');
    throw e;
  } finally {
    client.release();
  }
}
