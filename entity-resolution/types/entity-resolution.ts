// types/entity-resolution.ts

export type ResolutionMode = "entity" | "service";

// Base entity and cluster types
export interface Entity {
  id: string;
  organization_id: string; // Assuming services might also belong to an org or have a similar field
  name: string | null;
  created_at: Date | null;
  updated_at: Date | null;
  source_system: string | null;
  source_id: string | null;
}

// Service type (new)
export interface Service {
  id: string;
  name: string | null;
  // Add other service-specific fields if necessary, e.g., version, endpoint
  created_at: Date | null;
  updated_at: Date | null;
  source_system: string | null; // Assuming services also have a source system
  source_id: string | null; // Assuming services also have a source ID
}

export interface EntityGroup {
  id: string;
  entity_id_1: string;
  entity_id_2: string;
  confidence_score: number | null;
  pre_rl_confidence_score: number | null;
  method_type: string;
  match_values: MatchValues;
  confirmed_status: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
  created_at: Date | null;
  updated_at: Date | null;
  group_cluster_id?: string | null;
  reviewed_at?: Date | null;
  reviewer_id?: string | null;
}

// ServiceGroup type (new) - based on your schema
export interface ServiceGroup {
  id: string;
  service_id_1: string;
  service_id_2: string;
  confidence_score: number | null;
  pre_rl_confidence_score: number | null;
  method_type: string;
  match_values: MatchValues; // Assuming similar structure for match_values
  confirmed_status: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH'; // Consistent status
  created_at: Date | null;
  updated_at: Date | null;
  group_cluster_id?: string | null; // This is service_group_cluster_id in some contexts
  reviewed_at?: Date | null;
  reviewer_id?: string | null;
}


export interface BaseCluster { // Made generic for reuse
  id: string;
  name: string | null;
  description: string | null;
  average_coherence_score: number | null;
  created_at: Date | null;
  updated_at: Date | null;
}

export interface EntityCluster extends BaseCluster {
  entity_count: number;
  group_count: number;
}

export interface ServiceCluster extends BaseCluster { // New
  service_count: number;
  service_group_count: number; // Renamed from group_count for clarity
}

// Match decision and feedback types
export interface MatchDecisionDetails { // Potentially generic or duplicated for services
  id: string;
  // entity_group_id or service_group_id would be needed
  group_id: string; // Generic group_id
  pipeline_run_id: string | null;
  snapshotted_features: Record<string, unknown>;
  method_type_at_decision: string;
  pre_rl_confidence_at_decision: number;
  tuned_confidence_at_decision: number;
  confidence_tuner_version_at_decision: number | null;
  created_at: Date;
}

export interface HumanFeedbackBase { // Generic base for feedback
  reviewer_id: string;
  feedback_timestamp: Date;
  is_match_correct: boolean;
  notes: string | null;
  processed_for_tuner_update_at: Date | null;
  match_decision_id: string; // Assuming this ID refers to a record of why the match was initially proposed
}

export interface EntityHumanFeedback extends HumanFeedbackBase {
  id: string; // Feedback record ID
  entity_group_id: string;
}

export interface ServiceMatchHumanFeedback extends HumanFeedbackBase { // New
  // id will be auto-generated by DB
  service_group_id: string;
  // match_decision_id is already in HumanFeedbackBase
}


// Visualization types
export interface BaseNode { // Generic Node
  id: string;
  name: string;
}
export type EntityNode = BaseNode;
export type ServiceNode = BaseNode; // Services can also be nodes

export interface BaseLink { // Generic Link
  id: string; // This is the edge_visualization_id
  source: string; // entity_id_1 or service_id_1
  target: string; // entity_id_2 or service_id_2
  weight: number; // edge_weight
  status?: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
}
export type EntityLink = BaseLink;
export type ServiceLink = BaseLink; // Service connections can also be links

export interface VisualizationEntityEdge {
  id: string;
  cluster_id: string; // entity_group_cluster_id
  entity_id_1: string;
  entity_id_2: string;
  edge_weight: number;
  details: {
    methods: Array<{
      method_type: string;
      pre_rl_confidence: number;
      rl_confidence: number;
      combined_confidence: number;
    }>;
  };
  pipeline_run_id: string | null;
  created_at: Date;
  status?: EntityLink['status']; // Derived/set by frontend logic
  confirmed_status?: EntityGroup['confirmed_status'];
}

// ServiceEdgeVisualization type (new) - based on your schema
export interface VisualizationServiceEdge {
  id: string;
  cluster_id: string; // service_group_cluster_id
  service_id_1: string;
  service_id_2: string;
  edge_weight: number; // numeric(10,5) in DB, ensure conversion if needed
  details: Record<string, unknown> | null; // jsonb in DB
  pipeline_run_id: string;
  created_at: Date; // timestamp with time zone in DB
  status?: ServiceLink['status']; // Derived/set by frontend logic
  confirmed_status?: ServiceGroup['confirmed_status'];
}


// Match values structure (seems generic enough)
export interface MatchValues {
  type?: string;
  values: Record<string, any>;
}

// API request/response types
export interface GroupReviewApiPayloadBase {
  decision: GroupReviewDecision;
  reviewerId: string;
  notes?: string;
}
export type EntityGroupReviewApiPayload = GroupReviewApiPayloadBase;
export type ServiceGroupReviewApiPayload = GroupReviewApiPayloadBase; // New

export interface GroupReviewApiResponse { // Generic
  message: string;
}

export type GroupReviewDecision = 'ACCEPTED' | 'REJECTED'; // Generic

export interface ClusterFinalizationStatusResponse {
  status: 'COMPLETED_NO_SPLIT_NEEDED' | 'COMPLETED_SPLIT_OCCURRED' | 'PENDING_FULL_REVIEW' | 'CLUSTER_NOT_FOUND' | 'ERROR';
  message: string;
  originalClusterId: string;
  newClusterIds?: string[];
}

// API response types
export interface ClustersResponse<TCluster extends BaseCluster> { // Generic
  clusters: TCluster[];
  total: number;
  page: number;
  limit: number;
}
export type EntityClustersResponse = ClustersResponse<EntityCluster>;
export type ServiceClustersResponse = ClustersResponse<ServiceCluster>; // New

export interface VisualizationDataResponse<TNode extends BaseNode, TLink extends BaseLink, TGroup> { // Generic
  nodes: TNode[];
  links: TLink[];
  entityGroups: TGroup[]; // Represents the groups that form the links
}
export type EntityVisualizationDataResponse = VisualizationDataResponse<EntityNode, EntityLink, EntityGroup>;
export type ServiceVisualizationDataResponse = VisualizationDataResponse<ServiceNode, ServiceLink, ServiceGroup>; // New

export interface ConnectionDataResponse<TEdge, TGroup, TEntityOrService extends Entity | Service> { // Generic
  edge: TEdge;
  entityGroups: TGroup[]; // Groups specific to this edge
  matchDecisions: MatchDecisionDetails[]; // Assuming structure is similar
  entity1: TEntityOrService; // Represents the first node of the edge
  entity2: TEntityOrService; // Represents the second node of the edge
}
export type EntityConnectionDataResponse = ConnectionDataResponse<VisualizationEntityEdge, EntityGroup, Entity>;
export type ServiceConnectionDataResponse = ConnectionDataResponse<VisualizationServiceEdge, ServiceGroup, Service>; // New


export interface SuggestedAction {
  id: string;
  pipeline_run_id: string | null;
  action_type: string;
  entity_id: string | null; // or service_id
  group_id_1: string | null; // or service_group_id_1
  group_id_2: string | null; // or service_group_id_2
  cluster_id: string | null; // or service_cluster_id
  triggering_confidence: number | null;
  details: Record<string, unknown> | null;
  reason_code: string | null;
  reason_message: string | null;
  priority: number;
  status: string;
  reviewer_id: string | null;
  reviewed_at: Date | null;
  review_notes: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface ReviewOperationBase { // Generic
  groupId: string;
  // originalGroupStatus: EntityGroup['confirmed_status'] | ServiceGroup['confirmed_status'];
  originalGroupStatus: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
}

export interface QueuedReviewBatch {
  batchId: string;
  edgeId: string;
  clusterId: string;
  decision: GroupReviewDecision;
  reviewerId: string;
  operations: ReviewOperationBase[];
  // originalEdgeStatus: EntityLink['status'] | ServiceLink['status'];
  originalEdgeStatus: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
  // optimisticEdgeStatus: EntityLink['status'] | ServiceLink['status'];
  optimisticEdgeStatus: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
  // optimisticGroupStatus: EntityGroup['confirmed_status'] | ServiceGroup['confirmed_status'];
  optimisticGroupStatus: 'PENDING_REVIEW' | 'CONFIRMED_MATCH' | 'CONFIRMED_NON_MATCH';
  attempt: number;
  error?: string;
  processedOperations: Set<string>;
  failedOperations: Set<string>;
  isTerminalFailure?: boolean;
  mode: ResolutionMode; // To distinguish between entity and service feedback
}
